---
title: "Reproducible Research: Peer Assessment 1"
output: 
  html_document:
    keep_md: true
    toc : true
---


## Loading and preprocessing the data

### The Data

The data was accessed from:  
**URL:** <https://d396qusza40orc.cloudfront.net/repdata%2Fdata%2Factivity.zip>  
**Access Time:** 2018-08-07 20:14:20 BST.  
**Data Format:** ZIP Archive

### Download of, and Extracting the Raw Data

If the data is not downloaded, the data is downloaded from the above URL. If the data has been previously downloaded and named as data.zip, the script prints a message and moves onto the next step.

```{r message=FALSE}
if (!file.exists("data.zip")) {
     message("Downloading data from 'https://d396qusza40orc.cloudfront.net/repdata%2Fdata%2Factivity.zip'... Please wait")
     download.file(url = "https://d396qusza40orc.cloudfront.net/repdata%2Fdata%2Factivity.zip", destfile = "data.zip", method = "curl")
} else {
     message("Data already downloaded as data.zip")
}
```

If the data is not extracted, the data is extracted from data.zip. If the data has been previously extracted to to "UCI HAR Data set", the script prints a message and moves onto the next step.

```{r message = FALSE}
if (file.exists("data.zip") & !file.exists("activity.csv")) {
     message("Extracting data to './activity.csv'... Please wait")
     unzip("data.zip")
} else {
     message("Data already extracted to ./activity.csv")
}
```

### Preprocessing the data

The following libraries and versions, were used in the preprocessing and manipulation of the data

| Package    | Version |
|------------|:--------|
| data.table | 1.11.4  |
| dplyr      | 0.7.6   |
| tidyr      | 0.8.1   |
| lubridate  | 1.7.4   |
| ggplot2    | 3.0.0   |

If installed, they can be loaded as follows:

```{r libraries, message=FALSE, warning=FALSE, include=TRUE}
library(data.table)
library(dplyr)
library(tidyr)
library(lubridate)
library(ggplot2)
```

The data was read into a data.frame, `data` using `read.csv()`.

```{r}
data <- read.csv("activity.csv")
```

The data.frame `data` contained three columns as shown by the `names()` function: "steps"; "date"; and "interval". 

```{r}
names(data)
```
The variables included in this data set are:

* `steps`: *\<integer\>* Number of steps taking in a 5-minute interval (missing
    values are coded as `NA`).

* `date`: *\<factor\>* The date on which the measurement was taken in YYYY-MM-DD
    format.

* `interval`: *\<integer\>* Identifier for the 5-minute interval in which
    measurement was taken. Note, values for this variable of 345, 2125 and 0 would correspond to times (in HH:MM format) of 03:45, 21:25 and 00:00 (midnight) respectively.

As mapping trends relating to specific days and/or parts of the week would be of interest, two character vectors were defined to easily map the result of inputting date data into the lubridate function `wday()` to the desired result (i.e. the day of the week or if day of the week is weekday/weekend).

```{r}
week_day <- c("Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday")
week_end <- c("weekend","weekday","weekday","weekday","weekday","weekday","weekend")
```

* `week_day`: *\<character\>* Character vector of the days of the week where `week_day[1]` maps to Sunday to be consistent with the output of the lubridate function `wday()`.

* `week_end`: *\<character\>* Character vector based upon the days of the week where `week_end[1]` maps to the result for a Sunday to be consistent with the output of the lubridate function `wday()`. In this variable, Saturday and Sunday are classified as weekend days (`weekend`), while Monday, Tuesday, Wednesday, Thursday and Friday are classified as week days (`weekday`).

In order to be able to calculate statistics based upon day of the week and part of the week the columns `week.day` and `week.end` were added to the original data set, `data` by using the `mutate()` function. The `date` column was converted from *\<factor\>* to *\<date\>* type using the `as.Date` function. A random sample of rows from the mutated data.frame, `data` is also given to demonstrate the effect of the transformation and the current state of the data set.

```{r}
data <- mutate(data,
     date       = as.Date(date, format = "%Y-%m-%d"),
     week.day   = week_day[wday(date)],
     week.end   = week_end[wday(date)]
     )
data[sample(nrow(data), 10),]
```

## What is mean total number of steps taken per day?

The total, mean and median steps taken per day, named `steps.total`, `steps.mean` and `steps.median` were calculated and the result placed into a data.frame, `steps_stats`. This was achieved by grouping the data.frame `data` by `date` and piping the output to `summarise()` with the appropriate quantites calculated. A sample of the data.frame `steps_stats` can also be seen.

```{r}
steps_stats <- data %>%
     group_by(.,date) %>%
     summarise(.,
          steps.total  = sum(steps),
          steps.mean   = mean(steps),
          steps.median = median(steps)
     )

head(steps_stats)
```

A line with point plot of `steps.total` versus `date` was produced using the data.frame, `step_stats` using `ggplot` from the `ggplot2` package. The major x-tics are spaced one week apart. Notible here, are the missing values introduced by the "`NA`" values.

```{r message=FALSE, warning=FALSE}
ggplot(steps_stats,
aes(x=date, y=steps.total, group=1)) + geom_line() + geom_point() +
labs(title = "Total Steps Vs. Date", x = "Date", y = "Total Steps") +
scale_x_date(date_breaks = "1 week", date_minor_breaks = "1 day", date_labels = "%b %d") +
theme_classic()
```

## What is the average daily activity pattern?

The mean daily pattern is derived in a similar way to the previous section where I calculated the previous data.frame, `day_stats`. The total, mean and median steps taken per interval, named `steps.total`, `steps.mean` and `steps.median` were calculated and the result placed into a data.frame, `day_stats`. This was achieved by grouping the data.frame `data` by `interval` and piping the output to `summarise()` with the appropriate quantites calculated. A sample of the data.frame `day_stats` can also be seen.

```{r}
day_stats <- data %>%
     group_by(.,interval) %>%
     summarise(.,
          steps.total  = sum(steps, na.rm=TRUE),
          steps.mean   = mean(steps, na.rm=TRUE),
          steps.median = median(steps, na.rm=TRUE)
     )

head(day_stats)
```

A line with point plot of `steps.total` versus `interval` was produced using the data.frame, `day_stats` using `ggplot` from the `ggplot2` package. The major x-tics are spaced apart by 200 (i.e. 2 hours).

```{r message=FALSE, warning=FALSE}
ggplot(day_stats,
aes(x=interval, y=steps.total, group=1)) + geom_line() + geom_point() +
labs(title = "Mean Steps Vs. Interval", x = "Interval", y = "Mean Steps") +
scale_x_continuous(limits = c(0,2350), breaks = seq(0,2400,200)) +
theme_classic()
```

The maximum value can be seen by the spike on the graph above and by ordering `day_stats` asending by `steps.mean` by using the `aarange()` function. The maximum average daily activity occurs durring `interval = 835` which corresponds to the time 08:35.

```{r}
head(day_stats %>% arrange(.,desc(steps.mean)))
```

## Imputing missing values

The data has serveral days that are missing which are denoted in the data set as "`NA`". In order to fill in the blanks in the data I will consider a value of "`NA`" equal to 0. Therefore, I substitute all the "`NA`" values in the `steps` column of `data` using `replace_na()` from the tidyr package. The output of the mutation of the data.frame was output to a new data.frame, `data_tidy`.

```{r}
data_tidy <- mutate(
     data,
     steps   = replace_na(steps,0),
     w_day   = week_day[wday(date)],
     w_end   = week_end[wday(date)]
     )
```

## Are there differences in activity patterns between weekdays and weekends?
